package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math"
	"os"
	"strconv"
	"time"

	"github.com/adshao/go-binance/v2"
	"github.com/adshao/go-binance/v2/futures"
	"github.com/joho/godotenv"
)

func init() {
	if err := godotenv.Load(); err != nil {
		log.Print("No .env file found")
	}
}

// Convert milliseconds to time.Time
func MillisecondsToTime(milliseconds int64) time.Time {
	return time.Unix(0, milliseconds*int64(time.Millisecond))
}

func main() {
	for _ = range time.Tick(time.Second * 30) {
		fmt.Println("----------------------")
		apiKey, exists := os.LookupEnv("BINANCE_API_KEY")
		if exists {
			fmt.Println("apiKey exist")
		}

		secretKey, exexists := os.LookupEnv("BINANCE_SECRET_KEY")
		if exexists {
			fmt.Println("secretKey exist")
		}

		tickerName := "BTCUSDT"

		futuresClient := binance.NewFuturesClient(apiKey, secretKey)
		res, err := futuresClient.NewDepthService().Symbol(tickerName).Do(context.Background())
		if err != nil {
			fmt.Println(err)
			return
		}
		// fmt.Println(res)

		depthVar, _ := json.Marshal(res)
		// fmt.Println(string(depthVar))

		type AutoGenerated struct {
			LastUpdateID int64 `json:"lastUpdateId"`
			E            int64 `json:"E"`
			T            int64 `json:"T"`
			Bids         []struct {
				Price    string `json:"Price"`
				Quantity string `json:"Quantity"`
			} `json:"bids"`
			Asks []struct {
				Price    string `json:"Price"`
				Quantity string `json:"Quantity"`
			} `json:"asks"`
		}

		var autoGenerated AutoGenerated
		json.Unmarshal(depthVar, &autoGenerated)
		fmt.Println("----------------------")
		fmt.Println("----------------------")
		fmt.Println("ASK:", autoGenerated.Asks[0].Price, "-", autoGenerated.Asks[0].Quantity)
		fmt.Println("BID:", autoGenerated.Bids[0].Price, "-", autoGenerated.Bids[0].Quantity)
		fmt.Println("----------------------")

		klines, err := futuresClient.NewKlinesService().Symbol(tickerName).Interval("1h").Do(context.Background())
		if err != nil {
			fmt.Println(err)
			return
		}
		klinesVar, _ := json.Marshal(klines)

		type AutoGeneratedKlines []struct {
			OpenTime                 int64  `json:"openTime"`
			Open                     string `json:"open"`
			High                     string `json:"high"`
			Low                      string `json:"low"`
			Close                    string `json:"close"`
			Volume                   string `json:"volume"`
			CloseTime                int64  `json:"closeTime"`
			QuoteAssetVolume         string `json:"quoteAssetVolume"`
			TradeNum                 int    `json:"tradeNum"`
			TakerBuyBaseAssetVolume  string `json:"takerBuyBaseAssetVolume"`
			TakerBuyQuoteAssetVolume string `json:"takerBuyQuoteAssetVolume"`
		}

		var autoGeneratedKlines AutoGeneratedKlines
		json.Unmarshal(klinesVar, &autoGeneratedKlines)
		t := MillisecondsToTime(autoGeneratedKlines[498].CloseTime)
		fmt.Println("Last kline:")
		fmt.Println(t)
		fmt.Println("1h open :", autoGeneratedKlines[498].Open)
		fmt.Println("1h close:", autoGeneratedKlines[498].Close)
		fmt.Println("1h high :", autoGeneratedKlines[498].High)
		fmt.Println("1h low  :", autoGeneratedKlines[498].Low)
		fmt.Println("----------------------")

		tStart := MillisecondsToTime(autoGeneratedKlines[0].CloseTime)
		fmt.Println("Start history:")
		fmt.Println(tStart)
		fmt.Println("1h open :", autoGeneratedKlines[0].Open)
		fmt.Println("1h close:", autoGeneratedKlines[0].Close)
		fmt.Println("1h high :", autoGeneratedKlines[0].High)
		fmt.Println("1h low  :", autoGeneratedKlines[0].Low)
		fmt.Println("----------------------")

		resAcc, err := futuresClient.NewGetAccountService().Do(context.Background())
		if err != nil {
			fmt.Println(err)
			return
		}
		// fmt.Println(resAcc)

		accVar, _ := json.Marshal(resAcc)
		// fmt.Println(accVar)

		type Account struct {
			FeeTier                     int    `json:"feeTier"`
			CanTrade                    bool   `json:"canTrade"`
			CanDeposit                  bool   `json:"canDeposit"`
			CanWithdraw                 bool   `json:"canWithdraw"`
			UpdateTime                  int64  `json:"updateTime"`
			TotalInitialMargin          string `json:"totalInitialMargin"`
			TotalMaintMargin            string `json:"totalMaintMargin"`
			TotalWalletBalance          string `json:"totalWalletBalance"`
			TotalUnrealizedProfit       string `json:"totalUnrealizedProfit"`
			TotalMarginBalance          string `json:"totalMarginBalance"`
			TotalPositionInitialMargin  string `json:"totalPositionInitialMargin"`
			TotalOpenOrderInitialMargin string `json:"totalOpenOrderInitialMargin"`
			TotalCrossWalletBalance     string `json:"totalCrossWalletBalance"`
			TotalCrossUnPnl             string `json:"totalCrossUnPnl"`
			AvailableBalance            string `json:"availableBalance"`
			MaxWithdrawAmount           string `json:"maxWithdrawAmount"`
		}

		var account Account
		json.Unmarshal(accVar, &account)
		fmt.Println("----------------------")

		accountStart := 18.149229049682617 + 7.53667852 + 11.86
		accountNowString := account.AvailableBalance
		if accountNowFloat, err := strconv.ParseFloat(accountNowString, 32); err == nil {
			fmt.Println(accountStart, "- start")
			fmt.Println(accountNowFloat, "- now")
			fmt.Print("proffit($) = ", accountNowFloat-accountStart, "$", "\n")
			if accountNowFloat < accountStart {
				fmt.Print("proffit(%) = -", (accountNowFloat/accountStart)*100, "%")
			} else {
				fmt.Print("proffit(%) = ", (accountNowFloat/accountStart)*100, "%")
			}
		}
		fmt.Println()

		startLowString := autoGeneratedKlines[0].Low
		var startLowFloat float64
		if s, err := strconv.ParseFloat(startLowString, 32); err == nil {
			startLowFloat = s
		}
		fmt.Println("Start kline low =", startLowFloat)

		// Make low slice float64
		var nextLowFloat float64
		var lowSliceFloat64 []float64
		lowSliceFloat64 = append(lowSliceFloat64, startLowFloat)
		// fmt.Println(lowSliceFloat64)

		for i := 1; i < len(autoGeneratedKlines); i++ {
			nextLowString := autoGeneratedKlines[i].Low
			if s1, err := strconv.ParseFloat(nextLowString, 32); err == nil {
				nextLowFloat = s1
				lowSliceFloat64 = append(lowSliceFloat64, nextLowFloat)
			}
		}

		min := lowSliceFloat64[0]
		for _, number := range lowSliceFloat64 {
			if number < min {
				min = number
			}
		}

		fmt.Println("Lowest price    =", min)

		// Make high slice float64
		var nextHighFloat float64
		var highSliceFloat64 []float64

		for l := 0; l < len(autoGeneratedKlines); l++ {
			nextHighString := autoGeneratedKlines[l].High
			if s2, err := strconv.ParseFloat(nextHighString, 32); err == nil {
				nextHighFloat = s2
				highSliceFloat64 = append(highSliceFloat64, nextHighFloat)
			}
		}

		max := highSliceFloat64[0]
		for _, number := range highSliceFloat64 {
			if number > max {
				max = number
			}
		}

		fmt.Println("Highest price   =", max)
		fmt.Println("----------------------")

		shortFib236 := min + ((max - min) * 0.236)
		fmt.Println("short Fibo 236 =", shortFib236)
		shortFib382 := min + ((max - min) * 0.382)
		fmt.Println("short Fibo 382 =", shortFib382)
		shortFib500 := min + ((max - min) * 0.500)
		fmt.Println("short Fibo 500 =", shortFib500)
		shortFib618 := min + ((max - min) * 0.618)
		fmt.Println("short Fibo 618 =", shortFib618)
		shortFib786 := min + ((max - min) * 0.786)
		fmt.Println("short Fibo 786 =", shortFib786)

		priceCorridor := max - min
		fmt.Println("----------------------")
		fmt.Println("Price corridor    =", priceCorridor)
		priceCorridorPercent := ((max - min) / max) * 100
		fmt.Print("Price corridor(%) = ", math.Round(priceCorridorPercent*100)/100, "%\n")
		fmt.Println("----------------------")

		accServ, err := futuresClient.NewGetAccountService().Do(context.Background())
		if err != nil {
			fmt.Println(err)
			return
		}
		accServVar, _ := json.Marshal(accServ)
		// fmt.Println(accServVar, reflect.TypeOf(accServVar))

		fileJson, err := json.Marshal(accServ)
		if err != nil {
			panic(err)
		}
		err = ioutil.WriteFile("fileJson.json", fileJson, 0644)
		if err != nil {
			panic(err)
		}

		type AutoGeneratedPos struct {
			Assets []struct {
				Asset                  string `json:"asset"`
				InitialMargin          string `json:"initialMargin"`
				MaintMargin            string `json:"maintMargin"`
				MarginBalance          string `json:"marginBalance"`
				MaxWithdrawAmount      string `json:"maxWithdrawAmount"`
				OpenOrderInitialMargin string `json:"openOrderInitialMargin"`
				PositionInitialMargin  string `json:"positionInitialMargin"`
				UnrealizedProfit       string `json:"unrealizedProfit"`
				WalletBalance          string `json:"walletBalance"`
			} `json:"assets"`
			FeeTier                     int    `json:"feeTier"`
			CanTrade                    bool   `json:"canTrade"`
			CanDeposit                  bool   `json:"canDeposit"`
			CanWithdraw                 bool   `json:"canWithdraw"`
			UpdateTime                  int    `json:"updateTime"`
			TotalInitialMargin          string `json:"totalInitialMargin"`
			TotalMaintMargin            string `json:"totalMaintMargin"`
			TotalWalletBalance          string `json:"totalWalletBalance"`
			TotalUnrealizedProfit       string `json:"totalUnrealizedProfit"`
			TotalMarginBalance          string `json:"totalMarginBalance"`
			TotalPositionInitialMargin  string `json:"totalPositionInitialMargin"`
			TotalOpenOrderInitialMargin string `json:"totalOpenOrderInitialMargin"`
			TotalCrossWalletBalance     string `json:"totalCrossWalletBalance"`
			TotalCrossUnPnl             string `json:"totalCrossUnPnl"`
			AvailableBalance            string `json:"availableBalance"`
			MaxWithdrawAmount           string `json:"maxWithdrawAmount"`
			Positions                   []struct {
				Isolated               bool   `json:"isolated"`
				Leverage               string `json:"leverage"`
				InitialMargin          string `json:"initialMargin"`
				MaintMargin            string `json:"maintMargin"`
				OpenOrderInitialMargin string `json:"openOrderInitialMargin"`
				PositionInitialMargin  string `json:"positionInitialMargin"`
				Symbol                 string `json:"symbol"`
				UnrealizedProfit       string `json:"unrealizedProfit"`
				EntryPrice             string `json:"entryPrice"`
				MaxNotional            string `json:"maxNotional"`
				PositionSide           string `json:"positionSide"`
				PositionAmt            string `json:"positionAmt"`
				Notional               string `json:"notional"`
				IsolatedWallet         string `json:"isolatedWallet"`
				UpdateTime             int64  `json:"updateTime"`
			} `json:"positions"`
		}

		var autoGeneratedpos AutoGeneratedPos
		json.Unmarshal(accServVar, &autoGeneratedpos)

		var positionBTCindex int

		for k := 0; k < len(autoGeneratedpos.Positions); k++ {
			if autoGeneratedpos.Positions[k].Symbol == "ETHUSDT" {
				positionBTCindex = k
			}
		}
		fmt.Println("index position ETH -", positionBTCindex)
		fmt.Println("Unrealized profit =", autoGeneratedpos.TotalUnrealizedProfit)
		fmt.Println("The entry price position -", autoGeneratedpos.Positions[positionBTCindex].EntryPrice)
		fmt.Println("Position size", autoGeneratedpos.Positions[positionBTCindex].PositionAmt)
		fmt.Println("Item positions total -", len(autoGeneratedpos.Positions))
		fmt.Println("----------------------")

		var startTrade bool = false

		if priceCorridorPercent > 10 {
			fmt.Println(priceCorridorPercent, "> 10")
			fmt.Println("Corridor > 10 - you can trade")
			startTrade = true
		} else {
			fmt.Println("Corridor < 10 - you can't trade")
			startTrade = false
		}

		fmt.Println("Start trade =", startTrade)
		fmt.Println("----------------------")

		var bidPriceFloat float64

		if bidPriceFloat, err = strconv.ParseFloat(autoGenerated.Bids[0].Price, 32); err != nil {
			fmt.Println(err)
		}

		var priceBelow236 bool = false
		if (bidPriceFloat < shortFib236) && (bidPriceFloat > min) {
			priceBelow236 = true
		} else {
			priceBelow236 = false
		}
		fmt.Println("Price below 236 fibo =", priceBelow236)

		priceBelow382 := (bidPriceFloat < shortFib382) && (bidPriceFloat > shortFib236)
		fmt.Println("Price below 382 fibo =", priceBelow382)

		var priceBelow500 bool = (bidPriceFloat < shortFib500) && (bidPriceFloat > shortFib382)
		fmt.Println("Price below 500 fibo =", priceBelow500)

		var priceBelow618 bool = (bidPriceFloat < shortFib618) && (bidPriceFloat > shortFib500)
		fmt.Println("Price below 618 fibo =", priceBelow618)

		var priceBelow786 bool = (bidPriceFloat < shortFib786) && (bidPriceFloat > shortFib618)
		fmt.Println("Price below 786 fibo =", priceBelow786)

		var positionSizeFloat float64
		if positionSizeFloat, err = strconv.ParseFloat(autoGeneratedpos.Positions[positionBTCindex].PositionAmt, 32); err != nil {
			fmt.Println(err)
		}
		openPosition := false
		if positionSizeFloat != 0 {
			openPosition = true
		} else {
			openPosition = false
		}
		// fmt.Println(openPosition)

		fmt.Println("----------------------")

		// Level 382 open short position
		var startShortTo382 bool = priceBelow382 && startTrade && !openPosition
		fmt.Println("Open short position to level 382 =", startShortTo382)

		openOrders, err := futuresClient.NewListOpenOrdersService().Symbol(tickerName).
			Do(context.Background())
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, o := range openOrders {
			fmt.Println(o)
			fmt.Println(len(openOrders), "orders have been opened")
		}

		conditionLimit382 := len(openOrders) == 0 && startShortTo382

		if conditionLimit382 {
			fmt.Println(len(openOrders), "orders have been opened")
			shortFib382String := fmt.Sprintf("%.0f", shortFib382)
			limitOrder, err := futuresClient.NewCreateOrderService().Symbol(tickerName).
				Side(futures.SideTypeSell).Type(futures.OrderTypeLimit).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.001").
				Price(shortFib382String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(limitOrder)
		}

		if len(openOrders) == 1 && startShortTo382 {
			shortFib500String := fmt.Sprintf("%.0f", shortFib500)
			stopOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeBuy).Type(futures.OrderTypeStopMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.001").
				StopPrice(shortFib500String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(stopOrder)
		}

		var takeProfit382Condition bool = positionSizeFloat != 0 && len(openOrders) == 1 && priceBelow382

		if takeProfit382Condition {
			shortFib236String := fmt.Sprintf("%.0f", shortFib236)
			takeProfitOrder, err := futuresClient.NewCreateOrderService().
				Symbol("ETHUSDT").Side(futures.SideTypeBuy).Type(futures.OrderTypeTakeProfitMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.001").StopPrice(shortFib236String).
				Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(takeProfitOrder)
		}

		// Level 500 open short position
		startShortTo500 := priceBelow500 && startTrade && !openPosition
		fmt.Println("Open short position to level 500 =", startShortTo500)

		if len(openOrders) == 0 && startShortTo500 {
			shortFib500String := fmt.Sprintf("%.0f", shortFib500)
			limitOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeSell).Type(futures.OrderTypeLimit).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.002").
				Price(shortFib500String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(limitOrder)
		}

		if len(openOrders) == 1 && startShortTo500 {
			shortFib618String := fmt.Sprintf("%.0f", shortFib618)
			stopOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeBuy).Type(futures.OrderTypeStopMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.002").
				StopPrice(shortFib618String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(stopOrder)
		}

		takeProfit500Condition := positionSizeFloat != 0 && len(openOrders) == 1 && priceBelow500

		if takeProfit500Condition {
			shortFib618String := fmt.Sprintf("%.0f", shortFib618)
			takeProfitOrder, err := futuresClient.NewCreateOrderService().
				Symbol("ETHUSDT").Side(futures.SideTypeBuy).Type(futures.OrderTypeTakeProfitMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.002").StopPrice(shortFib618String).
				Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(takeProfitOrder)
		}

		// Level 618 open short position
		startShortTo618 := priceBelow618 && startTrade && !openPosition
		fmt.Println("Open short position to level 618 =", startShortTo618)

		if len(openOrders) == 0 && startShortTo618 {
			shortFib618String := fmt.Sprintf("%.0f", shortFib618)
			limitOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeSell).Type(futures.OrderTypeLimit).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.003").
				Price(shortFib618String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(limitOrder)
		}

		if len(openOrders) == 1 && startShortTo618 {
			shortFib786String := fmt.Sprintf("%.0f", shortFib786)
			stopOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeBuy).Type(futures.OrderTypeStopMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.003").
				StopPrice(shortFib786String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(stopOrder)
		}

		takeProfit618Condition := positionSizeFloat != 0 && len(openOrders) == 1 && priceBelow618

		if takeProfit618Condition {
			shortFib500String := fmt.Sprintf("%.0f", shortFib500)
			takeProfitOrder, err := futuresClient.NewCreateOrderService().
				Symbol("ETHUSDT").Side(futures.SideTypeBuy).Type(futures.OrderTypeTakeProfitMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.003").StopPrice(shortFib500String).
				Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(takeProfitOrder)
		}

		// Level 786 open short position
		startShortTo786 := priceBelow786 && startTrade && !openPosition
		fmt.Println("Open short position to level 786 =", startShortTo786)

		if len(openOrders) == 0 && startShortTo786 {
			shortFib786String := fmt.Sprintf("%.0f", shortFib786)
			limitOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeSell).Type(futures.OrderTypeLimit).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.005").
				Price(shortFib786String).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(limitOrder)
		}

		if len(openOrders) == 1 && startShortTo786 {
			maxString := fmt.Sprintf("%.0f", max)
			stopOrder, err := futuresClient.NewCreateOrderService().Symbol("ETHUSDT").
				Side(futures.SideTypeBuy).Type(futures.OrderTypeStopMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.005").
				StopPrice(maxString).Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(stopOrder)
		}

		takeProfit786Condition := positionSizeFloat != 0 && len(openOrders) == 1 && priceBelow786

		if takeProfit786Condition {
			shortFib618String := fmt.Sprintf("%.0f", shortFib618)
			takeProfitOrder, err := futuresClient.NewCreateOrderService().
				Symbol("ETHUSDT").Side(futures.SideTypeBuy).Type(futures.OrderTypeTakeProfitMarket).
				TimeInForce(futures.TimeInForceTypeGTC).Quantity("0.005").StopPrice(shortFib618String).
				Do(context.Background())
			if err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println(takeProfitOrder)
		}

		var openOrderSize []string

		for _, o := range openOrders {
			openOrderSize = append(openOrderSize, o.OrigQuantity)
		}
		fmt.Println(openOrderSize)
		for x, y := range openOrders {
			if y != openOrders[x] {
				fmt.Println("The order sizes are not equal")
				err = futuresClient.NewCancelAllOpenOrdersService().
					Symbol(tickerName).Do(context.Background())
				if err != nil {
					fmt.Println(err)
				}
			}
		}
		fmt.Println("*******************************************")

		fmt.Println("----------------------")
	}
}
